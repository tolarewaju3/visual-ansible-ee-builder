import { FileText, Download, AlertTriangle, Save, Package } from "lucide-react";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { Textarea } from "@/components/ui/textarea";
import { Separator } from "@/components/ui/separator";
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Checkbox } from "@/components/ui/checkbox";
import { SavePresetDialog } from "@/components/SavePresetDialog";
import { useAuth } from "@/contexts/AuthContext";
import { Collection } from "@/lib/storage";
import { useState } from "react";
import JSZip from "jszip";

interface Step3ReviewProps {
  selectedBaseImage: string;
  selectedCollections: Collection[];
  requirements: string[];
  selectedPackages: string[];
}

export function Step3Review({
  selectedBaseImage,
  selectedCollections,
  requirements,
  selectedPackages
}: Step3ReviewProps) {
  const { user } = useAuth();
  const [showSaveDialog, setShowSaveDialog] = useState(false);
  
  // Build options state
  const [imageTag, setImageTag] = useState('my-ee:latest');
  const [runtime, setRuntime] = useState('auto');
  const [pushAfterBuild, setPushAfterBuild] = useState(false);
  
  // Packages that require Red Hat subscription
  const redHatSubscriptionPackages = ['telnet', 'tcpdump'];
  
  // Check if any selected packages require Red Hat subscription
  const hasRedHatPackages = selectedPackages.some(pkg => 
    redHatSubscriptionPackages.includes(pkg.toLowerCase())
  );
  
  const redHatPackagesFound = selectedPackages.filter(pkg => 
    redHatSubscriptionPackages.includes(pkg.toLowerCase())
  );
  const generateExecutionEnvironment = () => {
    const collections = selectedCollections.map(c => c.version ? `${c.name}:${c.version}` : c.name);
    const dependenciesLines = ['  ansible_core:', '    package_pip: ansible-core==2.14.4', '  ansible_runner:', '    package_pip: ansible-runner'];
    if (selectedCollections.length > 0) {
      dependenciesLines.push('  galaxy: requirements.yml');
    }
    if (requirements.length > 0) {
      dependenciesLines.push('  python: requirements.txt');
    }
    if (selectedPackages.length > 0) {
      dependenciesLines.push('  system: bindep.txt');
    }
    return `---
version: 3

images:
  base_image:
    name: '${selectedBaseImage}'

dependencies:
${dependenciesLines.join('\n')}`;
  };

  const generateRequirementsTxt = () => {
    return requirements.join('\n');
  };

  const generateBindepsTxt = () => {
    return selectedPackages.join('\n');
  };

  const generateRequirementsYml = () => {
    return `---
collections:
${selectedCollections.map(c => `  - name: ${c.name}${c.version ? `\n    version: "${c.version}"` : ''}`).join('\n')}`;
  };

  const generateBuildScript = () => {
    return `#!/bin/bash

# Build script for Ansible Execution Environment
# Generated by Ansible EE Builder

set -e  # Exit on any error

IMAGE_TAG="${imageTag}"
RUNTIME="${runtime}"
PUSH_AFTER_BUILD="${pushAfterBuild}"

echo "Building Ansible Execution Environment..."
echo "Image tag: $IMAGE_TAG"
echo "Runtime: $RUNTIME"
echo "Push after build: $PUSH_AFTER_BUILD"
echo ""

# Auto-detect runtime if not specified
if [ "$RUNTIME" = "auto" ]; then
  if command -v podman &> /dev/null; then
    RUNTIME="podman"
    echo "Auto-detected runtime: podman"
  elif command -v docker &> /dev/null; then
    RUNTIME="docker"
    echo "Auto-detected runtime: docker"
  else
    echo "Error: Neither podman nor docker found"
    echo "Please install either podman or docker to build the execution environment"
    exit 1
  fi
fi

# Check if runtime is available
if ! command -v "$RUNTIME" &> /dev/null; then
  echo "Error: $RUNTIME is not installed or not in PATH"
  exit 1
fi

echo "Building execution environment with $RUNTIME..."
$RUNTIME build -t "$IMAGE_TAG" .

if [ $? -eq 0 ]; then
  echo "Build completed successfully!"
  
  # Conditionally push if enabled
  if [ "$PUSH_AFTER_BUILD" = "true" ]; then
    echo "Pushing image to registry..."
    $RUNTIME push "$IMAGE_TAG"
    if [ $? -eq 0 ]; then
      echo "Image pushed successfully!"
    else
      echo "Error: Failed to push image"
      exit 1
    fi
  fi
else
  echo "Error: Build failed"
  exit 1
fi

echo "Done!"
`;
  };

  const handleExportBuildPackage = async () => {
    const zip = new JSZip();

    // Add all generated files to the zip
    zip.file("execution-environment.yml", generateExecutionEnvironment());

    // Only include requirements.yml if there are collections
    if (selectedCollections.length > 0) {
      zip.file("requirements.yml", generateRequirementsYml());
    }

    // Only include requirements.txt if there are Python requirements
    if (requirements.length > 0) {
      zip.file("requirements.txt", generateRequirementsTxt());
    }

    // Only include bindep.txt if there are system packages
    if (selectedPackages.length > 0) {
      zip.file("bindep.txt", generateBindepsTxt());
    }

    // Add build script
    zip.file("build.sh", generateBuildScript());

    // Add README
    const readme = `# Ansible Execution Environment Build Package

This package contains all the files needed to build your Ansible Execution Environment locally.

## Files included:
- \`execution-environment.yml\`: Main EE configuration file
${selectedCollections.length > 0 ? '- `requirements.yml`: Ansible collections to install\n' : ''}${requirements.length > 0 ? '- `requirements.txt`: Python packages to install\n' : ''}${selectedPackages.length > 0 ? '- `bindep.txt`: System packages to install\n' : ''}- \`build.sh\`: Build script to create the container image
- \`README.md\`: This file

## Building the Execution Environment

1. Make the build script executable:
   \`\`\`bash
   chmod +x build.sh
   \`\`\`

2. Run the build script:
   \`\`\`bash
   ./build.sh
   \`\`\`

The script will automatically detect whether to use podman or docker, build the image with tag \`${imageTag}\`${pushAfterBuild ? ', and push it to the registry' : ''}.

## Requirements

- Either podman or docker must be installed
- Access to the internet for downloading base images and dependencies
${pushAfterBuild ? '- Registry credentials configured if pushing the image\n' : ''}
## Customization

You can modify the build options by editing the variables at the top of the \`build.sh\` script:
- \`IMAGE_TAG\`: Change the image name and tag
- \`RUNTIME\`: Force a specific runtime (podman/docker)
- \`PUSH_AFTER_BUILD\`: Enable/disable pushing to registry
`;

    zip.file("README.md", readme);

    // Generate and download the zip file
    const content = await zip.generateAsync({
      type: "blob"
    });
    const url = URL.createObjectURL(content);
    const link = document.createElement("a");
    link.href = url;
    link.download = "ee-build-package.zip";
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
  };

  const handleExportAll = async () => {
    const zip = new JSZip();

    // Add all generated files to the zip
    zip.file("execution-environment.yml", generateExecutionEnvironment());

    // Only include requirements.yml if there are collections
    if (selectedCollections.length > 0) {
      zip.file("requirements.yml", generateRequirementsYml());
    }

    // Only include requirements.txt if there are Python requirements
    if (requirements.length > 0) {
      zip.file("requirements.txt", generateRequirementsTxt());
    }

    // Only include bindep.txt if there are system packages
    if (selectedPackages.length > 0) {
      zip.file("bindep.txt", generateBindepsTxt());
    }

    // Generate and download the zip file
    const content = await zip.generateAsync({
      type: "blob"
    });
    const url = URL.createObjectURL(content);
    const link = document.createElement("a");
    link.href = url;
    link.download = "ee.zip";
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
  };

  return (
    <div className="space-y-6">
      <div className="space-y-6">
        {/* Red Hat Subscription Warning */}
        {hasRedHatPackages && (
          <Alert variant="destructive">
            <AlertTriangle className="h-4 w-4" />
            <AlertTitle>Red Hat Subscription Required</AlertTitle>
            <AlertDescription>
              The following packages require a Red Hat subscription: <strong>{redHatPackagesFound.join(', ')}</strong>
              <br />
              Make sure you are building the exeuction environment on Red Hat Enterprise Linux with a valid subscription.
            </AlertDescription>
          </Alert>
        )}

        {/* Generated Files */}
        <Card className="bg-card border-border">
          <CardHeader>
            <CardTitle className="flex items-center space-x-2">
              <FileText className="h-5 w-5 text-primary" />
              <span>Generated Files</span>
            </CardTitle>
          </CardHeader>
          <CardContent className="space-y-6">
            {/* execution-environment.yml */}
            <div className="space-y-2">
              <h4 className="text-sm font-medium text-foreground">execution-environment.yml</h4>
              <Textarea 
                value={generateExecutionEnvironment()} 
                readOnly 
                rows={generateExecutionEnvironment().split('\n').length} 
                className="font-mono text-xs bg-muted/30 text-foreground border resize-none" 
              />
            </div>

            {/* requirements.yml */}
            {selectedCollections.length > 0 && (
              <div className="space-y-2">
                <h4 className="text-sm font-medium text-foreground">requirements.yml</h4>
                <Textarea 
                  value={generateRequirementsYml()} 
                  readOnly 
                  rows={generateRequirementsYml().split('\n').length} 
                  className="font-mono text-xs bg-muted/30 text-foreground border resize-none" 
                />
              </div>
            )}

            {/* requirements.txt */}
            {requirements.length > 0 && (
              <div className="space-y-2">
                <h4 className="text-sm font-medium text-foreground">requirements.txt</h4>
                <Textarea 
                  value={generateRequirementsTxt()} 
                  readOnly 
                  rows={generateRequirementsTxt().split('\n').length} 
                  className="font-mono text-xs bg-muted/30 text-foreground border resize-none" 
                />
              </div>
            )}

            {/* bindep.txt */}
            {selectedPackages.length > 0 && (
              <div className="space-y-2">
                <h4 className="text-sm font-medium text-foreground">bindep.txt</h4>
                <Textarea 
                  value={generateBindepsTxt()} 
                  readOnly 
                  rows={generateBindepsTxt().split('\n').length} 
                  className="font-mono text-xs bg-muted/30 text-foreground border resize-none" 
                />
              </div>
            )}
          </CardContent>
        </Card>

        {/* Build Locally Panel */}
        <Card className="bg-card border-border">
          <CardHeader>
            <CardTitle className="flex items-center space-x-2">
              <Package className="h-5 w-5 text-primary" />
              <span>Build Locally</span>
            </CardTitle>
            <CardDescription>
              Configure options for building the execution environment locally
            </CardDescription>
          </CardHeader>
          <CardContent className="space-y-4">
            <div className="grid gap-4 md:grid-cols-2">
              <div className="space-y-2">
                <Label htmlFor="image-tag">Image Tag</Label>
                <Input
                  id="image-tag"
                  placeholder="my-ee:latest"
                  value={imageTag}
                  onChange={(e) => setImageTag(e.target.value)}
                />
              </div>
              <div className="space-y-2">
                <Label htmlFor="runtime">Runtime</Label>
                <Select value={runtime} onValueChange={setRuntime}>
                  <SelectTrigger id="runtime">
                    <SelectValue />
                  </SelectTrigger>
                  <SelectContent>
                    <SelectItem value="auto">Auto</SelectItem>
                    <SelectItem value="podman">Podman</SelectItem>
                    <SelectItem value="docker">Docker</SelectItem>
                  </SelectContent>
                </Select>
              </div>
            </div>
            <div className="flex items-center space-x-2">
              <Checkbox 
                id="push-after-build" 
                checked={pushAfterBuild}
                onCheckedChange={(checked) => setPushAfterBuild(checked === true)}
              />
              <Label htmlFor="push-after-build">Push after build</Label>
            </div>
          </CardContent>
        </Card>

        {/* Export Actions */}
        <div className="flex gap-3">
          {user && (
            <Button 
              variant="outline" 
              size="lg" 
              onClick={() => setShowSaveDialog(true)}
              className="flex-1"
            >
              <Save className="h-5 w-5 mr-2" />
              Save as Preset
            </Button>
          )}
          <Button 
            variant="outline" 
            size="lg" 
            onClick={handleExportBuildPackage}
            className={user ? "flex-1" : "w-full"}
          >
            <Package className="h-5 w-5 mr-2" />
            Export Build Package
          </Button>
          <Button size="lg" className={user ? "flex-1" : "w-full"} onClick={handleExportAll}>
            <Download className="h-5 w-5 mr-2" />
            Export All
          </Button>
        </div>
      </div>

      {/* Save Preset Dialog */}
      <SavePresetDialog
        open={showSaveDialog}
        onOpenChange={setShowSaveDialog}
        baseImage={selectedBaseImage}
        collections={selectedCollections}
        requirements={requirements}
        packages={selectedPackages}
        onSuccess={() => {
          // Optional: Add any additional success handling
        }}
      />
    </div>
  );
}